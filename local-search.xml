<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣二叉树部分题目题解</title>
    <link href="/2024/01/20/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/20/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h4 id="1-二叉树展开为链表"><a href="#1-二叉树展开为链表" class="headerlink" title="1.二叉树展开为链表"></a>1.二叉树展开为链表</h4><ul><li><p>描述：</p></li><li><p>​把一棵二叉树展开为一条链表，链表的顺序就是二叉树的先序遍历顺序，链表实际上就是特殊的二叉树</p></li><li><p>总体说明：</p><ul><li>在原先基础上建立链表<ul><li>迭代，划分为三大模块再处理里面的内容（解法一）</li><li>先序遍历的逆过程，递归（解法二）</li><li>栈保存左右子树信息（解法三）</li></ul></li><li>新建链表（先序遍历保存下来，再形成链表）（解法四）<ul><li>递归或者的迭代的方式进行先序遍历依次保存节点</li></ul></li></ul></li><li><p>解法一：</p><ul><li>思路：按照先序遍历的思路<strong>直接在二叉树上做修改（迭代）</strong>，先是根节点，然后是左子树，最后是右子树；迭代每个根节点，把右子树挂到左子树的最右子节点，然后把左子树移到右子树的位置，原先的左子树置空。</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>public void flatten(TreeNode root) {<br>   while(root !&#x3D; null){<br>       if(root.left &#x3D;&#x3D; null){<br>           root &#x3D; root.right;<br>       }else{<br>           TreeNode tmp &#x3D; root.left;<br>           while(tmp.right !&#x3D; null){ &#x2F;&#x2F;遍历找到左子树的最右子节点<br>               tmp &#x3D; tmp.right;<br>           }<br>           tmp.right &#x3D; root.right;<br>           root.right &#x3D; root.left;<br>           root.left &#x3D; null;<br>           root &#x3D; root.right;<br>       }<br>   }<br>}<br>}</p></li><li><p>总结：根据先序遍历，<u>把根节点，左子树，右子树先作为三个part连成一个链表</u>，然后再依次<strong>迭代</strong>里面的内容</p></li><li><p>解法二</p><ul><li>思路：先序遍历的逆过程，如果从根节点开始按照先序遍历的顺序直接建立链表，那么它的右节点就会还没有遍历到就直接被覆盖掉了。所以转换思维，从链尾开始倒着建立链表（root.right&#x3D;pre,root.left&#x3D;null），根据先右子树后左子树的迭代，<strong>自底向上</strong>倒序连接形成链表。</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>TreeNode pre;<br>public void flatten(TreeNode root) {<br>    if(root &#x3D;&#x3D; null) return;<br>    flatten(root.right);<br>    flatten(root.left);<br>    root.right &#x3D; pre;<br>    root.left &#x3D; null;<br>    pre &#x3D; root;<br>}<br>}</p></li><li><p>总结：很棒的想法，通过递归实现的顺序是<strong>右子树，左子树，根节点</strong>，刚好是先序遍历的逆序，再逐步组织链表。</p></li><li><p>解法三：</p><ul><li>思路：之前提到直接按照先序遍历建立链表会覆盖掉原先的右子树，那么可以通过<strong>栈的方式保存子树信息</strong>，先存右子树，再存左子树，申明一个前置节点，刚开始是root,从栈中先取出来的是左子树的根节点，pre.right &#x3D; cur; pre.left &#x3D; null;然后更新pre即可</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>public void flatten(TreeNode root) {<br>    if(root &#x3D;&#x3D; null) return;<br>    Deque<TreeNode> stack &#x3D; new LinkedList&lt;&gt;();<br>    stack.push(root);<br>    TreeNode pre &#x3D; null;<br>    while(!stack.isEmpty()){<br>        TreeNode cur &#x3D; stack.pop();<br>        if(pre !&#x3D; null){<br>            pre.right &#x3D; cur;<br>            pre.left &#x3D; null;<br>        }<br>        if(cur.right !&#x3D; null){<br>            stack.push(cur.right);<br>        }<br>        if(cur.left !&#x3D; null){<br>            stack.push(cur.left);<br>        }<br>        pre &#x3D; cur;<br>    }<br>}<br>}</p></li><li><p>总结：递归迭代这些好像经常可以和栈联系起来，栈的作用主要是保存状态，使得程序的遍历可以更加符合逻辑。</p></li><li><p>解法四：</p><ul><li>思路：以上的方法都是直接在二叉树上修改，使之变成链表，实际上也可以直接申明一个List<Treenode> 类型的list,先序遍历二叉树，把节点按顺序放入list，最后连接起一个链表即可。</li></ul></li></ul><h4 id="2-将有序数组转换为二叉搜索树"><a href="#2-将有序数组转换为二叉搜索树" class="headerlink" title="2.将有序数组转换为二叉搜索树"></a>2.将有序数组转换为二叉搜索树</h4><ul><li><p>描述：给定一个升序数组，将其转化为一个高度平衡的二叉搜索树，即中序遍历是个升序数组</p></li><li><p>解法一：</p><ul><li>思路：高度平衡，考虑把中间位置作为根节点进行建树，再递归调用建立左右子树即可。</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>public TreeNode sortedArrayToBST(int[] nums) {<br>    return helper(nums, 0, nums.length - 1);<br>}<br>public TreeNode helper(int[] nums, int left, int right){<br>    if(left &gt; right) return null;<br>    int mid &#x3D; (left + right)&#x2F;2;<br>    TreeNode root &#x3D; new TreeNode(nums[mid]);<br>    root.left &#x3D; helper(nums, left, mid -1);<br>    root.right &#x3D; helper(nums, mid + 1, right);<br>    return root;<br>}<br>}</p></li><li><p>总结：数组转化为二叉树思路并不难，只是对树的建立过程不够熟悉。因为涉及递归，最好新建一个函数。</p></li></ul><h4 id="3-二叉树的最近公共祖先"><a href="#3-二叉树的最近公共祖先" class="headerlink" title="3.二叉树的最近公共祖先"></a>3.二叉树的最近公共祖先</h4><ul><li><p>描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</p></li><li><p>解法一：</p><ul><li>思路：通过递归分别去左右子树寻找，一旦找到p或q，直接返回，或者两者分别在左右子树，返回当前的root</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br>    if(root &#x3D;&#x3D; null || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;<br>    TreeNode left &#x3D; lowestCommonAncestor(root.left, p, q);<br>    TreeNode right &#x3D; lowestCommonAncestor(root.right, p, q);<br>    if(left &#x3D;&#x3D; null) return right;<br>    if(right &#x3D;&#x3D; null) return left;<br>    return root;<br>}<br>}</p></li><li><p>总结：很精彩的递归，尤其是return root 这里，空的会向上传，直到有一个left和right都恰好是非空。</p></li><li><p>解法二：</p><ul><li>思路：先提前dfs整棵树，确定所有的父节点，然后找出p的父节点这条路，再找q的所有祖先，一旦之前找到过，就是最近的公共祖先</li></ul></li><li><p>代码：</p></li><li><p>class Solution {<br>Map&lt;Integer, TreeNode&gt; parent &#x3D; new HashMap&lt;&gt;();<br>Set<Integer> visited &#x3D; new HashSet&lt;&gt;();<br>public void dfs(TreeNode root){<br>    if(root.left !&#x3D; null){<br>        parent.put(root.left.val, root);<br>        dfs(root.left);<br>    }<br>    if(root.right !&#x3D; null){<br>        parent.put(root.right.val, root);<br>        dfs(root.right);<br>    }<br>​    }<br>​    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br>​        dfs(root);<br>​        while(p !&#x3D; null){<br>​            visited.add(p.val);<br>​            p &#x3D; parent.get(p.val);<br>​        }<br>​        while(q !&#x3D; null){<br>​            if(visited.contains(q.val)){<br>​                return q;<br>​            }<br>​            q &#x3D; parent.get(q.val);<br>​        }<br>​        return null;<br>​    }<br>}</p></li><li><p>总结：这个代码相对递归更好理解，就是直观的解法，后面的p，q就不是这两个点了，而是它们所有直接祖先这条线上的点。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课设复盘</title>
    <link href="/2024/01/19/%E8%AF%BE%E8%AE%BE%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/01/19/%E8%AF%BE%E8%AE%BE%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="大三上两次课程设计复盘"><a href="#大三上两次课程设计复盘" class="headerlink" title="大三上两次课程设计复盘"></a>大三上两次课程设计复盘</h1><h4 id="1-数据库管理系统课设"><a href="#1-数据库管理系统课设" class="headerlink" title="1.数据库管理系统课设"></a>1.数据库管理系统课设</h4><ul><li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？<ul><li>6个人的小组，需要完成一个数据库管理系统，包括文件结构存储，实现DDL,DML语句。</li></ul></li><li><strong>Task：</strong> 任务。你的任务是什么？<ul><li>担任组长</li><li>挑选合适的项目作为开发基础</li><li>对任务进行分工，包括从开发任务到汇报文档</li></ul></li><li><strong>Action：</strong> 行动。你做了什么？<ul><li>刚开始选择MYDB作为项目基础，但是其实现更偏原理性，可用性不强，且理解难度高，故舍弃</li><li>理解现有项目的实现，和组员讨论在此基础上要扩充的内容</li><li>合理分配任务，自己选择最难的select语句实现</li><li>帮助组员解决技术卡克点</li><li>制作ppt,向老师进行汇报答辩</li></ul></li><li><strong>Result：</strong> 结果。最终的结果怎样？<ul><li>既定的任务实现了90%，没有实现的是预先没有直接分配的那个任务</li><li>实现了前端界面和所有基本语句的支持，项目比较完整</li><li>答辩汇报也比较顺利，问答环节每个人回答到位</li></ul></li><li><strong>收获：</strong><ul><li>此次的专业技能提升主要在于编写select语句上，大力出奇迹的感觉，第一次真正用编码解决实际问题，虽然其实现性较为有限</li><li>软实力提升了不少，包括和组员共同能力，对整个项目进度的掌控能力，以及最后汇报的表达能力，均得到了提升</li></ul></li></ul><h4 id="2-软件文档-人脸识别Android-app课设"><a href="#2-软件文档-人脸识别Android-app课设" class="headerlink" title="2.软件文档-人脸识别Android app课设"></a>2.软件文档-人脸识别Android app课设</h4><ul><li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？<ul><li>需要开发一个系统实现人脸识别考勤签到，教师学生信息管理以及权限管理系统</li></ul></li><li><strong>Task：</strong> 任务。你的任务是什么？<ul><li>协助组长，帮助其推进项目</li></ul></li><li><strong>Action：</strong> 行动。你做了什么？<ul><li>最开始选择基础项目，敲定使用一个功能比较全的app项目</li><li>最近项目环境配置，一直不成功，在网上联系技术专家解决</li><li>最后项目部署上线，协助组长</li><li>一些文档编写，包括ER图的绘制</li></ul></li><li><strong>Result：</strong> 结果。最终的结果怎样？<ul><li>是唯一一个把app做出来的小组 ，其他都是网页版的实现，实现部分拿到了满分</li></ul></li><li><strong>收获：</strong><ul><li>专业技术：ER图建模，对关系型数据库建模的逻辑性有了更深的理解；Android项目的基本认识；项目部署上线流程有了大致的了解。</li><li>软能力：<ul><li>对一个更大项目的整体实现的认识，从各种文档的编写，前期需求分析，到ER图建模，项目选型，技术实现，部署上线，有了一个更加直观的体验；</li><li>学习到一些组织一个8人小组的经验</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学校项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p> 这是一篇测试文章：</p><img src="/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
