<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot-demo-HelloWorld</title>
    <link href="/2024/01/21/SpringBoot-demo-HelloWorld/"/>
    <url>/2024/01/21/SpringBoot-demo-HelloWorld/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-boot-demo-helloworld"><a href="#spring-boot-demo-helloworld" class="headerlink" title="spring-boot-demo-helloworld"></a>spring-boot-demo-helloworld</h1><h3 id="1-总体说明"><a href="#1-总体说明" class="headerlink" title="1.总体说明"></a>1.总体说明</h3><ul><li>一个基本的SpringBoot应用程序，其中包含一个Restful控制器，用于响应http的get请求。</li></ul><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootDemoHelloworldApplication</span> &#123;  <span class="hljs-comment">//主类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">//程序入口并启动SpringBoot应用程序</span><br>        SpringApplication.run(SpringBootDemoHelloworldApplication.class, args);<br>    &#125; <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hello，World</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> who 参数，非必须</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Hello, $&#123;who&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span> <span class="hljs-comment">//使用HTTP的get请求，将“/hello”路径映射到sayHello方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(required = false, name = &quot;who&quot;)</span> String who)</span> &#123;<span class="hljs-comment">//接受一个可选的查询参数名为who,绑定到参数who上</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(who)) &#123;<br>            who = <span class="hljs-string">&quot;World&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> StrUtil.format(<span class="hljs-string">&quot;Hello, &#123;&#125;!&quot;</span>, who); <span class="hljs-comment">//将占位符&#123;&#125;用&quot;who&quot;参数的值替换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-详细解释"><a href="#3-详细解释" class="headerlink" title="3.详细解释"></a>3.详细解释</h3><ul><li><strong>@SpringBootApplication</strong>：标记SpringBoot应用程序的<strong>主类</strong>，是一个<strong>配置类</strong>，并启用了Spring<u>上下文</u>的自动配置</li><li><strong>@RestController</strong>：定义Spring MVC应用程序中的<strong>控制器类</strong>，表示类中方法的返回值是**<u>HTTP响应体</u>**（而不是依赖于视图技术）。</li></ul><h3 id="4-一些深入"><a href="#4-一些深入" class="headerlink" title="4.一些深入"></a>4.一些深入</h3><h4 id="4-1-什么是Sping上下文？"><a href="#4-1-什么是Sping上下文？" class="headerlink" title="4.1 什么是Sping上下文？"></a>4.1 什么是Sping上下文？</h4><p>​<em>Spring 上下文（Spring Context）是 Spring 框架中的一个核心概念，它是一个<strong>对象容器</strong>，负责管理和维护应用程序中的所有<strong>对象（bean）</strong>。Spring 上下文充当了容器，负责<strong>加载、配置和组织</strong>应用程序中的各个组件，以及<strong>管理</strong>它们之间的<strong>依赖关系</strong>。</em></p><ul><li>我的理解：感觉还是有点抽象，先留个印象吧</li></ul><h4 id="4-2-什么是视图技术？"><a href="#4-2-什么是视图技术？" class="headerlink" title="4.2 什么是视图技术？"></a>4.2 什么是视图技术？</h4><p>常见的视图技术包括：</p><ol><li><strong>JSP（JavaServer Pages）：</strong> JSP 是一种基于 Java 的服务器端模板技术，允许将 Java 代码嵌入到 HTML 页面中。JSP 文件通常包含 HTML 标记和嵌入的 Java 代码，用于动态生成页面内容。</li><li><strong>Thymeleaf：</strong> Thymeleaf 是一种现代的服务器端模板引擎，支持自然的模板语法，而且可以直接在浏览器中预览模板。它特别适用于构建 HTML5 页面。</li></ol><p><code>@Controller</code> 注解通常与视图技术结合使用，将处理结果封装到模型中，然后选择适当的<u>视图来呈现这些模型数据</u>。</p><p> <code>@RestController</code> 注解表示控制器类的方法的返回值<u><strong>直接作为 HTTP 响应体</strong></u>，不再依赖于视图技术。</p><h4 id="4-3遇到的问题和解决"><a href="#4-3遇到的问题和解决" class="headerlink" title="4.3遇到的问题和解决"></a>4.3遇到的问题和解决</h4><ul><li>问题：自己照着编写了一个MyHelloworldApplication,但是运行失败</li><li>原因分析：两个主类基本一致，产生了<strong>映射冲突</strong>，导致两个不同的 <code>@RestController</code> 类中的相同路径 <code>/hello</code> 被映射到了相同的方法上</li><li>解决：更改其中一个路径为&#x2F;myHello,解决问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringBoot-Demo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣二叉树部分题目题解</title>
    <link href="/2024/01/20/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/20/%E5%8A%9B%E6%89%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​对于树一直是有一种惧怕心理的，题目做的不够多，有思路都不知道怎么实现，希望通过这次二叉树的专项练习，可以入个门吧~~~：）</p><hr><h3 id="1-二叉树展开为链表"><a href="#1-二叉树展开为链表" class="headerlink" title="1.二叉树展开为链表"></a>1.二叉树展开为链表</h3><ul><li>描述：把一棵二叉树展开为一条链表，链表的顺序就是二叉树的先序遍历顺序，链表实际上就是特殊的二叉树</li><li>总体说明：<ul><li>在原先基础上建立链表<ul><li>迭代，划分为三大模块再处理里面的内容（解法一）</li><li>先序遍历的逆过程，递归（解法二）</li><li>栈保存左右子树信息（解法三）</li></ul></li><li>新建链表（先序遍历保存下来，再形成链表）（解法四）<ul><li>递归或者的迭代的方式进行先序遍历依次保存节点</li></ul></li></ul></li></ul><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><ul><li><p>思路：按照先序遍历的思路<strong>直接在二叉树上做修改（迭代）</strong>，先是根节点，然后是左子树，最后是右子树；迭代每个根节点，把右子树挂到左子树的最右子节点，然后把左子树移到右子树的位置，原先的左子树置空。</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(root.left == <span class="hljs-literal">null</span>)&#123;<br>               root = root.right;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> root.left;<br>               <span class="hljs-keyword">while</span>(tmp.right != <span class="hljs-literal">null</span>)&#123; <span class="hljs-comment">//遍历找到左子树的最右子节点</span><br>                   tmp = tmp.right;<br>               &#125;<br>               tmp.right = root.right;<br>               root.right = root.left;<br>               root.left = <span class="hljs-literal">null</span>;<br>               root = root.right;<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：根据先序遍历，<u>把根节点，左子树，右子树先作为三个part连成一个链表</u>，然后再依次<strong>迭代</strong>里面的内容</li></ul><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><ul><li><p>思路：先序遍历的逆过程。如果从根节点开始按照先序遍历的顺序<strong>直接</strong>建立链表，那么它的右节点就会还没有遍历到就直接被覆盖掉了。所以转换思维，从链尾开始倒着建立链表（root.right&#x3D;pre,root.left&#x3D;null）pre是链表上当前root的后一个节点，根据先右子树后左子树的<strong>递归</strong>，<strong>自底向上</strong>倒序连接形成链表。</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode pre;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        flatten(root.right);<br>        flatten(root.left);<br>        root.right = pre;<br>        root.left = <span class="hljs-literal">null</span>; <br>        pre = root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：很棒的想法，通过递归实现的顺序是<u><strong>右子树，左子树，根节点</strong></u>，刚好是先序遍历（根节点，左子树，右子树）的逆序，再逐步组织链表。</li></ul><h4 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h4><ul><li><p>思路：之前提到直接按照先序遍历建立链表会覆盖掉原先的右子树，那么可以通过<strong>栈的方式保存子树信息</strong>，先存右子树，再存左子树，申明一个前置节点，刚开始是root,从栈中先取出来的是左子树的根节点，pre.right &#x3D; cur; pre.left &#x3D; null;然后更新pre即可。最终实现<strong>自顶向下</strong>建立链表。</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">null</span>)&#123;<br>                pre.right = cur;<br>                pre.left = <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>)&#123;<br>                stack.push(cur.left);<br>            &#125;<br>            pre = cur;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：递归迭代这些好像经常可以和栈联系起来，栈的作用主要是<strong>保存状态</strong>，使得程序的遍历可以更加符合**<u>顺序逻辑</u>**。</li></ul><h4 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h4><ul><li>思路：以上的方法都是直接在二叉树上修改，使之变成链表，实际上也可以直接申明一个List<Treenode> 类型的list,先序遍历二叉树，把节点按顺序放入list，最后连接起一个链表即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        preorderTraversal(root, list);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size()-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">//List类型转为单向链表</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> list.get(i), next = list.get(i + <span class="hljs-number">1</span>);<br>            cur.right = next;<br>            cur.left = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>)&#123;<br>            list.add(root);<br>            preorderTraversal(root.left, list);<br>            preorderTraversal(root.right, list);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：对于这种简单的递归要尽可能地熟练，并不难。</li></ul><h3 id="2-将有序数组转换为二叉搜索树"><a href="#2-将有序数组转换为二叉搜索树" class="headerlink" title="2.将有序数组转换为二叉搜索树"></a>2.将有序数组转换为二叉搜索树</h3><ul><li>描述：给定一个升序数组，将其转化为一个高度平衡的二叉搜索树，即中序遍历是个升序数组</li></ul><h4 id="解法一：-1"><a href="#解法一：-1" class="headerlink" title="解法一："></a>解法一：</h4><ul><li><p>思路：高度平衡，考虑把中间位置作为根节点进行建树，再递归调用建立左右子树即可。</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = helper(nums, left, mid -<span class="hljs-number">1</span>);<br>        root.right = helper(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：数组转化为二叉树思路并不难，只是对树的建立过程不够熟悉。因为涉及递归，最好新建一个函数。</li></ul><h3 id="3-二叉树的最近公共祖先"><a href="#3-二叉树的最近公共祖先" class="headerlink" title="3.二叉树的最近公共祖先"></a>3.二叉树的最近公共祖先</h3><ul><li>描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先</li></ul><h4 id="解法一：-2"><a href="#解法一：-2" class="headerlink" title="解法一："></a>解法一：</h4><ul><li><p>思路：通过递归分别去左右子树寻找，一旦找到p或q，直接返回，或者两者分别在左右子树，返回当前的root</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：很精彩的递归，尤其是return root 这里，空的会向上传，直到有一个left和right都恰好是非空。</li></ul><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><ul><li><p>思路：先提前dfs整棵树，确定所有的父节点，然后找出p的父节点这条路，再找q的所有祖先，一旦之前找到过，就是最近的公共祖先</p></li><li><p>代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, TreeNode&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Set&lt;Integer&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root.left != <span class="hljs-literal">null</span>)&#123;<br>            parent.put(root.left.val, root);<br>            dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.right != <span class="hljs-literal">null</span>)&#123;<br>            parent.put(root.right.val, root);<br>            dfs(root.right);<br>        &#125;<br><br>    &#125;<br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            visited.add(p.val);<br>            p = parent.get(p.val);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(visited.contains(q.val))&#123;<br>                <span class="hljs-keyword">return</span> q;<br>            &#125;<br>            q = parent.get(q.val);<br>       &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：这个代码相对递归更好理解，就是直观的解法，后面的p，q就不是这两个点了，而是它们所有直接祖先这条线上的点。</li></ul><h3 id="4-把二叉搜索树转化为累加树"><a href="#4-把二叉搜索树转化为累加树" class="headerlink" title="4.把二叉搜索树转化为累加树"></a>4.把二叉搜索树转化为累加树</h3><ul><li>描述：给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。补充：二叉搜索树的中序遍历是一个升序数组。</li></ul><h4 id="解法一：-3"><a href="#解法一：-3" class="headerlink" title="解法一："></a>解法一：</h4><ul><li>思路：逆向思维，从二叉搜索树的最右子节点开始，以中序遍历的逆过程（<strong>右子树，根节点，左子树</strong>）遍历，其值就是当前遍历过的节点的不断累加。</li><li>代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        convertBST(root.right);<br>        sum += root.val;<br>        root.val = sum;<br>        convertBST(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：增加了递归的熟练度，宏观来看就是<strong>右子树，根节点，左子树</strong>的顺序，具体的实现细节也要验证符合要求，很锻炼思维能力。</li></ul><h3 id="5-路径总和"><a href="#5-路径总和" class="headerlink" title="5.路径总和|||"></a>5.路径总和|||</h3><ul><li>描述：给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</li></ul><h4 id="解法一：-4"><a href="#解法一：-4" class="headerlink" title="解法一："></a>解法一：</h4><ul><li>思路：路径是从父节点到根节点，那么可以深度搜索遍历整棵树，同时维护一个前缀和的哈希数组，键是当前节点之前出现过的前缀和，值出现的次数，cur代表从根节点到达当前节点的所有的和。</li><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        Map&lt;Long, Integer&gt; prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        prefix.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, prefix, <span class="hljs-number">0</span>, targetSum);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, Map&lt;Long, Integer&gt; prefix, <span class="hljs-type">long</span> cur, <span class="hljs-type">int</span> targetSum&#123;</span><br><span class="hljs-params">        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//ret每次进来重新赋值，但由于下面的+=,最后会累加成最终的结果</span><br>        cur += root.val;<br>        ret = prefix.getOrDefault(cur - targetSum,<span class="hljs-number">0</span>);<br>        prefix.put(cur, prefix.getOrDefault(cur, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        ret += dfs(root.left, prefix, cur, targetSum);<br>        ret += dfs(root.right, prefix, cur, targetSum);<br>        prefix.put(cur,prefix.getOrDefault(cur, <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>); <span class="hljs-comment">//跳转到另一颗子树，必须恢复现场</span><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结：二叉树还是跟递归关系很大，主要是利用了前缀和的思想和Map这一键值对的数据结构，还有就是当当前节点遍历完，换到另一颗子树时一定要恢复现场，才能保证prefix的准确性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课设复盘</title>
    <link href="/2024/01/19/%E8%AF%BE%E8%AE%BE%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/01/19/%E8%AF%BE%E8%AE%BE%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="大三上两次课程设计复盘"><a href="#大三上两次课程设计复盘" class="headerlink" title="大三上两次课程设计复盘"></a>大三上两次课程设计复盘</h1><h4 id="1-数据库管理系统课设"><a href="#1-数据库管理系统课设" class="headerlink" title="1.数据库管理系统课设"></a>1.数据库管理系统课设</h4><ul><li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？<ul><li>6个人的小组，需要完成一个数据库管理系统，包括文件结构存储，实现DDL,DML语句。</li></ul></li><li><strong>Task：</strong> 任务。你的任务是什么？<ul><li>担任组长</li><li>挑选合适的项目作为开发基础</li><li>对任务进行分工，包括从开发任务到汇报文档</li></ul></li><li><strong>Action：</strong> 行动。你做了什么？<ul><li>刚开始选择MYDB作为项目基础，但是其实现更偏原理性，可用性不强，且理解难度高，故舍弃</li><li>理解现有项目的实现，和组员讨论在此基础上要扩充的内容</li><li>合理分配任务，自己选择最难的select语句实现</li><li>帮助组员解决技术卡克点</li><li>制作ppt,向老师进行汇报答辩</li></ul></li><li><strong>Result：</strong> 结果。最终的结果怎样？<ul><li>既定的任务实现了90%，没有实现的是预先没有直接分配的那个任务</li><li>实现了前端界面和所有基本语句的支持，项目比较完整</li><li>答辩汇报也比较顺利，问答环节每个人回答到位</li></ul></li><li><strong>收获：</strong><ul><li>此次的专业技能提升主要在于编写select语句上，大力出奇迹的感觉，第一次真正用编码解决实际问题，虽然其实现性较为有限</li><li>软实力提升了不少，包括和组员共同能力，对整个项目进度的掌控能力，以及最后汇报的表达能力，均得到了提升</li></ul></li></ul><h4 id="2-软件文档-人脸识别Android-app课设"><a href="#2-软件文档-人脸识别Android-app课设" class="headerlink" title="2.软件文档-人脸识别Android app课设"></a>2.软件文档-人脸识别Android app课设</h4><ul><li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？<ul><li>需要开发一个系统实现人脸识别考勤签到，教师学生信息管理以及权限管理系统</li></ul></li><li><strong>Task：</strong> 任务。你的任务是什么？<ul><li>协助组长，帮助其推进项目</li></ul></li><li><strong>Action：</strong> 行动。你做了什么？<ul><li>最开始选择基础项目，敲定使用一个功能比较全的app项目</li><li>最近项目环境配置，一直不成功，在网上联系技术专家解决</li><li>最后项目部署上线，协助组长</li><li>一些文档编写，包括ER图的绘制</li></ul></li><li><strong>Result：</strong> 结果。最终的结果怎样？<ul><li>是唯一一个把app做出来的小组 ，其他都是网页版的实现，实现部分拿到了满分</li></ul></li><li><strong>收获：</strong><ul><li>专业技术：ER图建模，对关系型数据库建模的逻辑性有了更深的理解；Android项目的基本认识；项目部署上线流程有了大致的了解。</li><li>软能力：<ul><li>对一个更大项目的整体实现的认识，从各种文档的编写，前期需求分析，到ER图建模，项目选型，技术实现，部署上线，有了一个更加直观的体验；</li><li>学习到一些组织一个8人小组的经验</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学校项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p> 这是一篇测试文章：</p><img src="/2024/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
